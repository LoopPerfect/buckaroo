package com.loopperfect.buckaroo.tasks;

import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Maps;
import com.loopperfect.buckaroo.*;
import com.loopperfect.buckaroo.io.EvenMoreFiles;
import io.reactivex.Observable;

import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.file.FileSystem;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

public final class InstallExistingTasks {

    private InstallExistingTasks() {

    }

    private static String toFolderName(final RecipeIdentifier identifier) {
        Preconditions.checkNotNull(identifier);
        return identifier.source.map(x -> x.name + "+").orElse("") +
            identifier.organization + "-" + identifier.recipe;
    }

    private static String generateBuckarooDeps(final ImmutableList<RecipeIdentifier> versions) {
        Preconditions.checkNotNull(versions);
        final String list = versions
            .stream()
            .map(x -> "  '" + toFolderName(x) + "//:" + x.recipe + "', \n") // TODO: x.target
            .collect(Collectors.joining(""));
        return "# Generated by Buckaroo, do not edit! \n" +
            "# This file should not be tracked in source-control. \n" +
            "BUCKAROO_DEPS = [\n" +
            list +
            "]\n";
    }

    private static Observable<DownloadProgress> downloadResolvedDependency(final FileSystem fs, final ResolvedDependency resolvedDependency, final Path target) {

        Preconditions.checkNotNull(fs);
        Preconditions.checkNotNull(resolvedDependency);
        Preconditions.checkNotNull(target);

        final Observable<DownloadProgress> downloadSourceCode = resolvedDependency.source.join(
            gitCommit -> Observable.error(new IOException("Git commit not supported yet. ")),
            remoteArchive -> CommonTasks.downloadRemoteArchive(fs, remoteArchive, target));

        final Path buckFilePath = fs.getPath(target.toString(), "BUCK");
        final Observable<DownloadProgress> downloadBuckFile = Files.exists(buckFilePath) ?
            Observable.empty() :
            resolvedDependency.buckResource
                .map(x -> CommonTasks.downloadRemoteFile(fs, x, buckFilePath))
                .orElse(Observable.empty());

        final Path buckarooDepsFilePath = fs.getPath(target.toString(), "BUCKAROO_DEPS");
        final Observable<DownloadProgress> writeBuckarooDeps = MoreObservables.fromAction(() -> {
            EvenMoreFiles.writeFile(
                buckarooDepsFilePath,
                generateBuckarooDeps(resolvedDependency.dependencies),
                Charset.defaultCharset(),
                true);
        });

        return Observable.concat(
            downloadSourceCode,
            downloadBuckFile,
            writeBuckarooDeps);
    }

    private static Observable<DownloadProgress> installDependencyLock(final FileSystem fs, final DependencyLock lock) {

        Preconditions.checkNotNull(fs);
        Preconditions.checkNotNull(lock);

        final Path dependencyFolder = fs.getPath(
            "buckaroo", toFolderName(lock.identifier)).toAbsolutePath();

        return downloadResolvedDependency(fs, lock.origin, dependencyFolder);
    }

    public static Observable<Map<DependencyLock, DownloadProgress>> installDependenciesFromLockFileInWorkingDirectory(final FileSystem fs) {

        Preconditions.checkNotNull(fs);

        return CommonTasks.readLockFile(fs.getPath("buckaroo.lock.json").toAbsolutePath()).toObservable()
            .flatMap((DependencyLocks locks) -> {
                final List<Observable<Map.Entry<DependencyLock, DownloadProgress>>> installs = locks.entries()
                    .stream()
                    .map(dependencyLock -> installDependencyLock(fs, dependencyLock)
                        .map(x -> Maps.immutableEntry(dependencyLock, x)))
                    .collect(ImmutableList.toImmutableList());

                return Observable.zip(
                    installs,
                    x -> ImmutableList.copyOf(x)
                        .stream()
                        .map(i -> (Map.Entry<DependencyLock, DownloadProgress>)i)
                        .collect(ImmutableMap.toImmutableMap(Map.Entry::getKey, Map.Entry::getValue)));
            });
    }
}
